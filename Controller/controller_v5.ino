
/*************************************************************************
MIT License
Copyright (c) 2020 Petar Crnjak
License file :
https://github.com/PCrnjak/S_Drive---small-BLDC-driver/blob/master/LICENSE
**************************************************************************/

#include <Arduino.h>
#include <SPI.h>
#include <PID_v1.h>
#include <AS5040.h>
#include <QuadratureEncoder.h>

double Setpoint;
double Input;
double Output;

double Kp = 1; // 0.3, 0.003
double Ki = 0.001;   // 4 , 11
double Kd = 0;// 0.01,0.0001

PID myPID(&Input, &Output, &Setpoint, Kp, Ki, Kd, DIRECT);

#define LED1 PA8
#define LED2 PB15

#define EN1 PC13
#define EN2 PC14
#define EN3 PC15

#define PULS1 PB7
#define PULS2 PB8
#define PULS3 PB9

#define BEMF1 PA1
#define BEMF2 PA2
#define BEMF3 PA3

#define SUPPLY PA0

#define CURRENT_pin PB0

#define CSn PB5 // ih HIGH state locks Index ,A,B to HIGH, going to LOW state releases them

#define Index PA15

#define Motor_Poles 14 // number of motor poles on rotor of motor

uint16_t PWM_freq = 40000 ; // PWM switching frequency

HardwareTimer pwmtimer4(4); // We use timer 4 and pins that have acces to that timer to set PWM frequency

Encoders BLDC_encoder(PB4,PB3); // Input pins of Quadrature encoder

/***********************************************************************************************************
* If you were to plot these numbers with some time t between them we would get a saddle profile wave
* Now by scaling these numbers by some number K we can control max amplitude of that saddle profile
* We can only scale down because max period in table is max duty cycle value we can use on our PWM output
************************************************************************************************************
* 1024 samples, 7 saddle profile periods , 1800 max amplitude
* Generated by https://github.com/PCrnjak/BLDC_SVPWM_lookup_table
************************************************************************************************************/
 const int pwmSin[] = { 900 ,  967 ,  1034 ,  1101 ,  1167 ,  1233 ,  1298 ,  1362 ,  1426 
 ,  1489 ,  1550 ,  1610 ,  1669 ,  1695 ,  1712 ,  1728 ,  1743 ,  1755 ,  1767 ,  1776 ,  1784 
 ,  1791 ,  1795 ,  1798 ,  1800 ,  1799 ,  1797 ,  1794 ,  1789 ,  1782 ,  1773 ,  1763 ,  1751 
 ,  1738 ,  1723 ,  1707 ,  1689 ,  1689 ,  1707 ,  1723 ,  1738 ,  1751 ,  1763 ,  1773 ,  1782 
 ,  1789 ,  1794 ,  1797 ,  1799 ,  1800 ,  1798 ,  1795 ,  1791 ,  1784 ,  1776 ,  1767 ,  1755 
 ,  1743 ,  1728 ,  1712 ,  1695 ,  1670 ,  1611 ,  1551 ,  1489 ,  1427 ,  1363 ,  1298 ,  1233 
 ,  1168 ,  1101 ,  1035 ,  968 ,  901 ,  834 ,  767 ,  700 ,  634 ,  568 ,  503 ,  438 ,  375 
 ,  312 ,  250 ,  190 ,  131 ,  105 ,  88 ,  72 ,  58 ,  45 ,  34 ,  24 ,  16 ,  10 ,  5 ,  2 
 ,  0 ,  1 ,  2 ,  6 ,  11 ,  18 ,  27 ,  37 ,  49 ,  62 ,  77 ,  93 ,  111 ,  112 ,  94 ,  77 
 ,  62 ,  49 ,  37 ,  27 ,  18 ,  11 ,  6 ,  3 ,  1 ,  0 ,  2 ,  5 ,  9 ,  16 ,  24 ,  33 ,  44 
 ,  57 ,  72 ,  87 ,  105 ,  130 ,  188 ,  249 ,  310 ,  373 ,  436 ,  501 ,  566 ,  632 ,  698 
 ,  765 ,  832 ,  899 ,  956 ,  1023 ,  1090 ,  1156 ,  1222 ,  1287 ,  1352 ,  1416 ,  1478 ,  1540
 ,  1601 ,  1660 ,  1692 ,  1710 ,  1726 ,  1740 ,  1753 ,  1765 ,  1775 ,  1783 ,  1790 ,  1795 
 ,  1798 ,  1800 ,  1800 ,  1798 ,  1795 ,  1790 ,  1783 ,  1775 ,  1765 ,  1753 ,  1740 ,  1726
 ,  1710 ,  1692 ,  1686 ,  1704 ,  1720 ,  1736 ,  1749 ,  1761 ,  1772 ,  1780 ,  1788 ,  1793 
 ,  1797 ,  1799 ,  1800 ,  1799 ,  1796 ,  1791 ,  1785 ,  1778 ,  1768 ,  1757 ,  1745 ,  1731 
 ,  1715 ,  1698 ,  1678 ,  1621 ,  1561 ,  1499 ,  1437 ,  1373 ,  1309 ,  1244 ,  1178 ,  1112 
 ,  1045 ,  979 ,  912 ,  845 ,  778 ,  711 ,  644 ,  579 ,  513 ,  449 ,  385 ,  322 ,  260 ,  200
 ,  141 ,  108 ,  91 ,  74 ,  60 ,  47 ,  35 ,  25 ,  17 ,  10 ,  5 ,  2 ,  0 ,  0 ,  2 ,  5 ,  10
 ,  17 ,  25 ,  35 ,  47 ,  60 ,  74 ,  90 ,  108 ,  115 ,  96 ,  80 ,  65 ,  51 ,  39 ,  29 ,  20 
 ,  12 ,  7 ,  3 ,  1 ,  0 ,  1 ,  4 ,  8 ,  15 ,  22 ,  32 ,  43 ,  55 ,  69 ,  85 ,  102 ,  122 ,  179 
 ,  239 ,  300 ,  363 ,  426 ,  490 ,  555 ,  621 ,  687 ,  754 ,  821 ,  888 ,  945 ,  1012 ,  1079 
 ,  1145 ,  1211 ,  1277 ,  1341 ,  1405 ,  1468 ,  1530 ,  1591 ,  1650 ,  1689 ,  1707 ,  1723 ,  1738 
 ,  1751 ,  1763 ,  1773 ,  1782 ,  1789 ,  1794 ,  1797 ,  1799 ,  1800 ,  1798 ,  1795 ,  1791 ,  1784 
 ,  1776 ,  1767 ,  1755 ,  1743 ,  1728 ,  1712 ,  1695 ,  1682 ,  1701 ,  1718 ,  1733 ,  1747 ,  1759
 ,  1770 ,  1779 ,  1787 ,  1792 ,  1796 ,  1799 ,  1800 ,  1799 ,  1796 ,  1792 ,  1787 ,  1779 ,  1770 
 ,  1759 ,  1747 ,  1733 ,  1718 ,  1701 ,  1682 ,  1630 ,  1571 ,  1509 ,  1447 ,  1384 ,  1320 ,  1255 
 ,  1189 ,  1123 ,  1056 ,  990 ,  923 ,  855 ,  789 ,  722 ,  655 ,  589 ,  524 ,  459 ,  395 ,  332 ,  270
 ,  210 ,  150 ,  111 ,  93 ,  77 ,  62 ,  49 ,  37 ,  27 ,  18 ,  11 ,  6 ,  3 ,  1 ,  0 ,  2 ,  5 ,  9 
 ,  16 ,  24 ,  33 ,  45 ,  57 ,  72 ,  88 ,  105 ,  118 ,  99 ,  82 ,  67 ,  53 ,  41 ,  30 ,  21 ,  14 
 ,  8 ,  4 ,  1 ,  0 ,  1 ,  4 ,  8 ,  13 ,  21 ,  30 ,  41 ,  53 ,  67 ,  82 ,  99 ,  117 ,  169 ,  229 
 ,  290 ,  352 ,  416 ,  480 ,  545 ,  610 ,  676 ,  743 ,  810 ,  877 ,  934 ,  1001 ,  1068 ,  1134 ,  1200 
 ,  1266 ,  1331 ,  1395 ,  1458 ,  1520 ,  1581 ,  1641 ,  1686 ,  1704 ,  1721 ,  1736 ,  1749 ,  1761
 ,  1772 ,  1780 ,  1788 ,  1793 ,  1797 ,  1799 ,  1800 ,  1799 ,  1796 ,  1791 ,  1785 ,  1778 ,  1768 
 ,  1757 ,  1745 ,  1731 ,  1715 ,  1698 ,  1679 ,  1698 ,  1715 ,  1731 ,  1745 ,  1757 ,  1768 ,  1778 
 ,  1785 ,  1791 ,  1796 ,  1799 ,  1800 ,  1799 ,  1797 ,  1793 ,  1788 ,  1780 ,  1772 ,  1761 ,  1749 
 ,  1736 ,  1720 ,  1704 ,  1686 ,  1640 ,  1580 ,  1519 ,  1457 ,  1394 ,  1330 ,  1265 ,  1200 ,  1134 
 ,  1067 ,  1001 ,  934 ,  866 ,  799 ,  733 ,  666 ,  600 ,  535 ,  470 ,  406 ,  343 ,  281 ,  220 ,  160 
 ,  114 ,  96 ,  80 ,  64 ,  51 ,  39 ,  28 ,  20 ,  12 ,  7 ,  3 ,  1 ,  0 ,  1 ,  4 ,  9 ,  15 ,  22 ,  32 
 ,  43 ,  55 ,  69 ,  85 ,  102 ,  121 ,  102 ,  85 ,  69 ,  55 ,  43 ,  32 ,  22 ,  15 ,  9 ,  4 ,  1 ,  0 ,  1 
 ,  3 ,  7 ,  12 ,  20 ,  28 ,  39 ,  51 ,  64 ,  79 ,  96 ,  114 ,  159 ,  219 ,  280 ,  342 ,  405 ,  469 ,  534 
 ,  600 ,  666 ,  732 ,  799 ,  866 ,  923 ,  990 ,  1057 ,  1124 ,  1190 ,  1255 ,  1320 ,  1384 ,  1448 ,  1510 ,  1571
 ,  1631 ,  1683 ,  1701 ,  1718 ,  1733 ,  1747 ,  1759 ,  1770 ,  1779 ,  1787 ,  1792 ,  1796 ,  1799 ,  1800 ,  1799 
 ,  1796 ,  1792 ,  1786 ,  1779 ,  1770 ,  1759 ,  1747 ,  1733 ,  1718 ,  1701 ,  1682 ,  1695 ,  1712 ,  1728 ,  1743 ,  1755 
 ,  1767 ,  1776 ,  1784 ,  1791 ,  1795 ,  1798 ,  1800 ,  1799 ,  1797 ,  1794 ,  1789 ,  1782 ,  1773 ,  1763 ,  1751 ,  1738 
 ,  1723 ,  1707 ,  1689 ,  1650 ,  1590 ,  1530 ,  1468 ,  1405 ,  1341 ,  1276 ,  1211 ,  1145 ,  1078 ,  1011 ,  945 ,  877 
 ,  810 ,  744 ,  677 ,  611 ,  545 ,  480 ,  416 ,  353 ,  291 ,  229 ,  170 ,  118 ,  99 ,  82 ,  67 ,  53 ,  41 ,  30 ,  21 
 ,  13 ,  8 ,  4 ,  1 ,  0 ,  1 ,  4 ,  8 ,  13 ,  21 ,  30 ,  41 ,  53 ,  67 ,  82 ,  99 ,  118 ,  105 ,  88 ,  72 ,  57 ,  45 
 ,  33 ,  24 ,  16 ,  9 ,  5 ,  2 ,  0 ,  1 ,  3 ,  6 ,  11 ,  18 ,  27 ,  37 ,  49 ,  62 ,  77 ,  93 ,  111 ,  150 ,  209 ,  270 
 ,  332 ,  395 ,  459 ,  523 ,  589 ,  655 ,  721 ,  788 ,  855 ,  912 ,  979 ,  1046 ,  1113 ,  1179 ,  1245 ,  1310 ,  1374 ,  1437 
 ,  1500 ,  1561 ,  1621 ,  1678 ,  1698 ,  1715 ,  1731 ,  1745 ,  1757 ,  1768 ,  1778 ,  1785 ,  1792 ,  1796 ,  1799 ,  1800 
 ,  1799 ,  1797 ,  1793 ,  1788 ,  1780 ,  1771 ,  1761 ,  1749 ,  1735 ,  1720 ,  1704 ,  1685 ,  1692 ,  1710 ,  1726 ,  1740
 ,  1753 ,  1765 ,  1775 ,  1783 ,  1790 ,  1795 ,  1798 ,  1800 ,  1800 ,  1798 ,  1795 ,  1790 ,  1783 ,  1775 ,  1765 ,  1753 
 ,  1740 ,  1726 ,  1709 ,  1692 ,  1659 ,  1600 ,  1540 ,  1478 ,  1415 ,  1351 ,  1287 ,  1221 ,  1156 ,  1089 ,  1022 ,  955 
 ,  888 ,  821 ,  755 ,  688 ,  622 ,  556 ,  491 ,  427 ,  363 ,  301 ,  239 ,  179 ,  122 ,  102 ,  85 ,  69 ,  55 ,  43 ,  32 
 ,  22 ,  15 ,  9 ,  4 ,  1 ,  0 ,  1 ,  3 ,  7 ,  12 ,  20 ,  28 ,  39 ,  51 ,  64 ,  80 ,  96 ,  114 ,  108 ,  90 ,  74 ,  60 
 ,  47 ,  35 ,  25 ,  17 ,  10 ,  5 ,  2 ,  0 ,  0 ,  2 ,  5 ,  10 ,  17 ,  25 ,  35 ,  47 ,  60 ,  74 ,  90 ,  108 ,  140 ,  199 
 ,  260 ,  322 ,  384 ,  448 ,  513 ,  578 ,  644 ,  710 ,  777 ,  844 ,  901 ,  968 ,  1035 ,  1102 ,  1168 ,  1234 ,  1299 ,  1364 
 ,  1427 ,  1490 ,  1551 ,  1612 ,  1670 ,  1695 ,  1713 ,  1728 ,  1743 ,  1756 ,  1767 ,  1776 ,  1784 ,  1791 ,  1795 ,  1798 
 ,  1800 ,  1799 ,  1797 ,  1794 ,  1789 ,  1782 ,  1773 ,  1763 ,  1751 ,  1738 ,  1723 ,  1706 ,  1688 ,  1689 ,  1707 ,  1723 
 ,  1738 ,  1751 ,  1763 ,  1773 ,  1782 ,  1789 ,  1794 ,  1798 ,  1799 ,  1800 ,  1798 ,  1795 ,  1790 ,  1784 ,  1776 ,  1766 
 ,  1755 ,  1742 ,  1728 ,  1712 ,  1695 ,  1669 ,  1610 ,  1550 ,  1488 ,  1425 ,  1362 ,  1297 ,  1232 ,  1166 ,  1100 ,  1033
 ,  966 ,  899 ,  832 ,  765 ,  699 ,  632 ,  567 ,  502 ,  437 ,  373 ,  311 ,  249 ,  189 ,  130 ,  105 ,  88 ,  72 ,  57 ,  45 
 ,  33 ,  24 ,  16 ,  9 ,  5 ,  2 ,  0 ,  1 ,  3 ,  6 ,  11 ,  18 ,  27 ,  37 ,  49 ,  62 ,  77 ,  93 ,  111 ,  111 ,  93 ,  77 ,  62 
 ,  49 ,  37 ,  27 ,  18 ,  11 ,  6 ,  3 ,  1 ,  0 ,  2 ,  5 ,  9 ,  16 ,  24 ,  33 ,  45 ,  57 ,  72 ,  88 ,  105 ,  131 ,  190 ,  250 
 ,  311 ,  374 ,  438 ,  502 ,  567 ,  633 ,  699 ,  766 ,  833 ,  900    };


bool flag_setup = 0;
bool flag_dir = 0;
bool flag_end = 0;
 
int out ;
 
int32_t EncoderCount = 0;
int32_t EncoderCount_ = 0;

int16_t currentStepA;
int16_t currentStepB;
int16_t currentStepC;

int16_t currentStepA_;
int16_t currentStepB_;
int16_t currentStepC_;

uint16_t lookup_table_size;

boolean dir_ = 1; // direction TRUE=forward, FALSE=backward

int16_t A;
int16_t B;
int16_t C;
uint16_t  over = 0;

int16_t max_ = 0;

double sped = 0;

int offset_1 = 37; // 481
int offset_0 = 111; // 148

float Current = 0.0;

uint16_t phaseShift = 0;
uint16_t phaseShift_2 = 0;

uint32_t currentMicros = 0;
uint32_t previousMicros = 0;


/***********************************************************************************************************
*Function prototypes
************************************************************************************************************/
void All_Enable_LOW();
void All_Enable_HIGH();
void PWM_ABC();
void PWM_ACB();
void set_PWM();
uint16_t Get_current();
void Lock_position(int A_,int B_,int C_,int Amplitude);
bool BLDC_Setup(int delay_, int max_A , int steps_);
void open_loop(int32_t _steps , bool dir_ , int Time_, int duty_);
void speed_(int sample_time);
void slow_speed(int sample_time);
uint16_t get_supply_voltage();
void move_BLDC(int direction_);

char data[10];
int i_ = 0;
int prev_setpoint = 0;
 
void setup() {

Serial1.begin(115200); // PA9 = TX1 , PA10 = RX1
//Serial3.begin(115200); // PB10 = TX3 , PB11 = RX3
delay(1000); 

pinMode(EN1, OUTPUT);
pinMode(EN2, OUTPUT);
pinMode(EN3, OUTPUT);
pinMode(CSn, OUTPUT);

pinMode(PULS1,PWM);
pinMode(PULS2,PWM);
pinMode(PULS3,PWM);

pinMode(BEMF1,INPUT_ANALOG);
pinMode(BEMF2,INPUT_ANALOG);
pinMode(BEMF3,INPUT_ANALOG);

pinMode(SUPPLY,INPUT_ANALOG);

pinMode(CURRENT_pin,INPUT_ANALOG);

digitalWrite(EN1,HIGH);
digitalWrite(EN2,HIGH);
digitalWrite(EN3,HIGH);
digitalWrite(CSn,LOW);

Setpoint = 200;

myPID.SetOutputLimits(0, 1000);

// sample time in ms
myPID.SetSampleTime(25);   
 
// set pwm freq
set_PWM();
   

lookup_table_size = sizeof(pwmSin)/sizeof(pwmSin[0]); // Find lookup table size
//Serial.println(lookup_table_size);
phaseShift = (lookup_table_size * 2) / (Motor_Poles * 3) ;
phaseShift_2 = phaseShift * 2;
      
currentStepA = 0;
currentStepB = currentStepA + phaseShift;
currentStepC = currentStepB + phaseShift; 

currentStepA_ = currentStepA;
currentStepB_ = currentStepB;
currentStepC_ = currentStepC;

/// STEPS, DIR ,SPEED* , AMPLITUDE
open_loop(500 ,1, 3000, 900);

//SPEED, AMPLITUDE ,STEPS
int set_ = BLDC_Setup(2000, 700, 500); // BLDC SETUP
delay(500);

/// lock to position
/// A,B,C, AMPLITUDE
Lock_position(pwmSin[0],pwmSin[phaseShift],pwmSin[phaseShift_2],1800);

   
delay(500);
BLDC_encoder.setEncoderCount(0);
delay(500);


myPID.SetMode(AUTOMATIC);


}





void loop() {


if(Serial1.available() > 0){
  data[i_] = Serial1.read();
  if(data[i_] == '\n'){
  data[i_ - 1] = '\0';
  prev_setpoint = Setpoint;
  Setpoint = atoi(data);
  Serial1.println(Setpoint);
  i_ = 0;
  
}else{
i_ = i_ + 1;
}
}



//Setpoint = 500;

Input = BLDC_encoder.getEncoderCount();
if(Input < Setpoint ){
  myPID.SetControllerDirection(DIRECT);
  dir_ = 1;
}
if (Input > Setpoint ){
  myPID.SetControllerDirection(REVERSE);
  dir_ = 0;
}

myPID.Compute();
//Serial1.println(BLDC_encoder.getEncoderCount());
max_ = (over * Output)/1000; 

move_BLDC(dir_);

//speed_(2000); // calculate speed in RPM every 2 ms 


}


/*****************************************************************************
* Set PWM frequency for IN1,IN2,IN3 pins
* These pins drive phases A,B,C 
* Duty cycle controls voltage applied to each phase
******************************************************************************/
void set_PWM(){

over = F_CPU / PWM_freq ; // maximum duty cycle value ( in our case 1800)
pwmtimer4.pause(); // pause timer
pwmtimer4.setPrescaleFactor(1); // sets prescale , 1 means 72Mhz is devided by one, so period is 1 / 72 Mhz
pwmtimer4.setOverflow(over); //every 2000, (1800 bi bilo 40khz) ticks of 1/72 Mhz we overflow, so our period is 2000 * (1/72Mhz) = 2.7777*e-5
pwmtimer4.refresh(); /// our frequency is 1 / 2.77777*e-5 == 36 khz
pwmtimer4.resume(); /// continue with new settings
/// this means that we can adjust our duty cycle with values 0-2000, 0 meaning 0%, 1000 = 50% and 2000 = 100%  
  
}


/*****************************************************************************
* Get current reading in mA 
* Max returned value is 5000mA  , or 5A
******************************************************************************/
uint16_t Get_current(){
uint16_t raw = analogRead(CURRENT_pin); // reads voltage from 0(0) to 3.3V(4095). 3.3v means that 5A of current is flowing 
uint16_t C_ = map(raw,0,4095,0,5000); // Map our reading to 0-5A times 1000, so we can avoid floats
return C_;
}

/*****************************************************************************
* Disable all 3 phases
******************************************************************************/
void All_Enable_LOW(){
digitalWrite(EN1,LOW);
digitalWrite(EN2,LOW);
digitalWrite(EN3,LOW);
}


/*****************************************************************************
* Enable all 3 phases
******************************************************************************/
void All_Enable_HIGH(){
digitalWrite(EN1,HIGH);
digitalWrite(EN2,HIGH);
digitalWrite(EN3,HIGH);
}


/*****************************************************************************
* PWM sequance for 1 direction 
******************************************************************************/
void PWM_ABC(){
 //pwmWrite(PIN_,DUTY_CYCLE);
   pwmWrite(PULS1,A);
   pwmWrite(PULS2,B);
   pwmWrite(PULS3,C);  
}

/*****************************************************************************
* PWM sequance for 0 direction 
* As you can see only phases B and C are switched
* That causes reverese direction
******************************************************************************/
void PWM_ACB(){
 //pwmWrite(PIN_,DUTY_CYCLE);
   pwmWrite(PULS1,A);
   pwmWrite(PULS2,C);
   pwmWrite(PULS3,B);  
}



/*****************************************************************************
* A_,B_,C_ are positions in our sine table 
* B_ must be offset by phase shift and C_ by 2 phase shifts from A_
* Amplitude represents "voltage" applied to phases (actually duty cycle value)
* over is maximum duty cycle value we can use:
* (1800 for 72MHZ CPU_CLOCK and PWM freq of 40kHz)
******************************************************************************/
void Lock_position(int A_,int B_,int C_,int Amplitude){
  
A = map(A_,0,over,0,Amplitude); 
B = map(B_,0,over,0,Amplitude);
C = map(C_,0,over,0,Amplitude);

PWM_ABC();
}



/*****************************************************************************
* TODO dir check...
******************************************************************************/
bool BLDC_Setup(int delay_, int max_A , int steps_) {

int incrm = 1;
static int prev_encoder ;
static bool dir_CW_ABC ;
static bool dir_CW_ACB;

while(flag_end == 0){

if(flag_setup == 0 ){
    prev_encoder = BLDC_encoder.getEncoderCount();
    flag_setup = 1;
}

currentMicros = micros();
if(currentMicros - previousMicros >= delay_){
  
    previousMicros = currentMicros;
    
    A = map(pwmSin[currentStepA],0,over,0,max_A);
    B = map(pwmSin[currentStepB],0,over,0,max_A);
    C = map(pwmSin[currentStepC],0,over,0,max_A);

    if(flag_dir == 0){
        PWM_ABC();
    }else{
      PWM_ACB();
    }

   currentStepA = currentStepA + incrm ;
   currentStepB = currentStepB + incrm ;
   currentStepC = currentStepC + incrm ;

  if(currentStepB == lookup_table_size) {
      currentStepB = 0; 
  }
  
  if(currentStepC == lookup_table_size) {   
      currentStepC = 0;
  }
   
  if(currentStepA == steps_ and flag_dir == 0){
      EncoderCount = BLDC_encoder.getEncoderCount();
      currentStepA = currentStepA_;
      currentStepB = currentStepB_;
      currentStepC = currentStepC_;
      flag_dir = 1;
          if(EncoderCount > prev_encoder ) {
              dir_CW_ABC = 1; // When shaft is rotating CW with ABC phase order ,encoder is counting up
         } else {
             dir_CW_ABC = 0;  // When shaft is rotating CW with ABC phase order ,encoder is counting down
   }
   
    delay(250);  
}

  if(currentStepA  == steps_  and flag_dir == 1){
      EncoderCount = BLDC_encoder.getEncoderCount();
      currentStepA = currentStepA_;
      currentStepB = currentStepB_;
      currentStepC = currentStepC_;
      flag_end = 1;
      flag_dir = 0;
      flag_setup = 0;
          if(EncoderCount > prev_encoder ) {
              dir_CW_ACB = 1; // When shaft is rotating CW with ACB phase order ,encoder is counting up
        } else {
             dir_CW_ACB = 0;  // When shaft is rotating CW with ACB phase order ,encoder is counting down
       }
   
      flag_end = 1;
      previousMicros  = 0;
      delay(250);
      if( dir_CW_ACB == 1){
        return 1;
      }else{
        return 0;
      }
   
}}}}


/*****************************************************************************
* Input variables are : Number of steps we want, direction of rotation
* Time between each step ( in microseconds) , duty cycle of pwm wave(torque)
******************************************************************************/
void open_loop(int32_t _steps , bool dir_ , int Time_, int duty_){

static int total_steps;

currentStepA = currentStepA_;
currentStepB = currentStepB_;
currentStepC = currentStepC_;
  
while ( total_steps < _steps){
  currentMicros = micros();
  if(currentMicros - previousMicros >= Time_){
    previousMicros = currentMicros;
    A = map(pwmSin[currentStepA],0,over,0,duty_);
    B = map(pwmSin[currentStepB],0,over,0,duty_);
    C = map(pwmSin[currentStepC],0,over,0,duty_);
    if(dir_ == 1 ){
      PWM_ABC();
    }else{
      PWM_ACB();
    }

    currentStepA = currentStepA + 1;
    currentStepB = currentStepB + 1;
    currentStepC = currentStepC + 1;

    total_steps = total_steps + 1;
 
    if(currentStepA > lookup_table_size){   
      currentStepA = 0;
    }
   
    if(currentStepB > lookup_table_size) {
      currentStepB = 0;
    }
  
    if(currentStepC > lookup_table_size){
      currentStepC = 0;
    }
  
  }
}

currentStepA = currentStepA_;
currentStepB = currentStepB_;
currentStepC = currentStepC_;


}


/*****************************************************************************
* calculate the speed of the motor in sample_time period
* Sample time is entered in us so 2500 will be 2.5 ms
*returns nothing speed is saved in global variable sped
******************************************************************************/
void speed_(int sample_time){
  
static int32_t Prev_EncoderCount_v = 0;
static uint32_t previousMicros_v = 0;  
uint32_t currentMicros_v = micros();

if(currentMicros_v - previousMicros_v >= sample_time){
  previousMicros_v = currentMicros_v;
  int32_t EncoderCount_v = BLDC_encoder.getEncoderCount();
  sped = (double)((EncoderCount_v - Prev_EncoderCount_v)*58573) / sample_time;  // *6134
  Prev_EncoderCount_v = EncoderCount_v ;
  //Serial.println(speed_*9.549,6);
  //sped = speed_ ;  // * 9.549
 //int var = analogRead(BEMF1);      
 //Serial.println(var); 
 //int current = Get_current();
//Serial1.println(current);
Serial1.println(BLDC_encoder.getEncoderCount());
}}



/*****************************************************************************
* We run BLDC motor as a stepper
* Min speed that is not too jerky is around 7 RPM
* sample_time in us
******************************************************************************/
void slow_speed(int sample_time){

static int32_t Prev_EncoderCount_t = 0;
static uint32_t previousMicros_t = 0;  
uint32_t currentMicros_t = micros();

if(currentMicros_t - previousMicros_t >= sample_time){
  previousMicros_t = currentMicros_t;
  Setpoint = Setpoint + 1;
}
  
}





/*****************************************************************************
*Get supply voltage in mV 
******************************************************************************/
uint16_t get_supply_voltage(){
uint16_t raw = analogRead(SUPPLY);
uint16_t v_ = map(raw,0,4095,0,40000); //max supply voltage is 40v DC
//float  volt  = (float)v_ / 1000 ;
//Serial1.println(volt);
return v_;
  
}


/*****************************************************************************
*Moves bldc in set direction 
******************************************************************************/
void move_BLDC(int direction_){

if( direction_ == 1 ){  
    if( EncoderCount < 1024 and EncoderCount >= 0){
            out = EncoderCount;
        }
        if( EncoderCount >= 1024 ){
            out =  EncoderCount - ( EncoderCount / 1024) *1024 ;
        }
        if( EncoderCount  > -1024  and EncoderCount < 0){
            out = 1024 + EncoderCount ;
        }
        if( EncoderCount <= -1024 ){
            out = EncoderCount + abs(1024*(EncoderCount / 1024)) + 1024;
            if(out == 1024){
            out =  0;
            }
        }
        ////////////////////////////////////////////////////////////////////////////
// offsets  maped encoder ticks by needed phase shift offsets (FOR PHASE A)
// shift to the left , positive shift
if(out>= (lookup_table_size-(offset_1)) ){
   currentStepA = abs((lookup_table_size) - ((offset_1) + out));
}
if(out>= 0 and out < (lookup_table_size-(offset_1))){
 currentStepA = out + (offset_1);
}
////////////////////////////////////////////////////////////////////////////
// offsets  maped encoder ticks by needed phase shift offsets (FOR PHASE B)
// shift to the left , positive shift
if(out>= (lookup_table_size-(offset_1+ phaseShift)) ){
   currentStepB = abs((lookup_table_size) - ((offset_1+ phaseShift) + out));
}
if(out>= 0 and out < (lookup_table_size-(offset_1+ phaseShift))){ 
 currentStepB = out + (offset_1+ phaseShift);
}
////////////////////////////////////////////////////////////////////////////
// offsets  maped encoder ticks by needed phase shift offsets (FOR PHASE C)
// shift to the left , positive shift
if(out>= (lookup_table_size-(offset_1+ phaseShift_2)) ){
   currentStepC = abs((lookup_table_size) - ((offset_1+ phaseShift_2) + out));
}
if(out>= 0 and out < (lookup_table_size-(offset_1+ phaseShift_2))){
 currentStepC = out + (offset_1+ phaseShift_2);
}

EncoderCount = BLDC_encoder.getEncoderCount();

A = map(pwmSin[abs(currentStepA)],0,over,0,max_);
B = map(pwmSin[abs(currentStepB)],0,over,0,max_);
C = map(pwmSin[abs(currentStepC)],0,over,0,max_);

PWM_ABC();

}else{
    if( EncoderCount < 1024 and EncoderCount >= 0){
            out = 1024 - EncoderCount ;  /// good
        }
        if( EncoderCount >= 1024 ){
            out = -EncoderCount + abs(1024*(EncoderCount / 1024)) + 1024;
            if(out == 1024){
            out =  0;
            }
        }
        if( EncoderCount  > -1024  and EncoderCount < 0){
            out = abs(EncoderCount) ; // good 
        }
        if( EncoderCount <= -1024 ){
            out =  abs(EncoderCount) + ( EncoderCount / 1024) *1024 ;  // good 
            if(out == 1024){
            out =  0;
            }
        }

        // offsets  maped encoder ticks by needed phase shift offsets (FOR PHASE A)
// shift to the left , positive shift
if(out>= (lookup_table_size-(offset_0)) ){
   currentStepA = abs((lookup_table_size) - ((offset_0) + out));
}
if(out>= 0 and out < (lookup_table_size-(offset_0))){
 currentStepA = out + (offset_0);
}
////////////////////////////////////////////////////////////////////////////
// offsets  maped encoder ticks by needed phase shift offsets (FOR PHASE B)
// shift to the left , positive shift
if(out>= (lookup_table_size-(offset_0+ phaseShift)) ){
   currentStepB = abs((lookup_table_size) - ((offset_0+ phaseShift) + out));
}
if(out>= 0 and out < (lookup_table_size-(offset_0+ phaseShift))){ 
 currentStepB = out + (offset_0+ phaseShift);
}
////////////////////////////////////////////////////////////////////////////
// offsets  maped encoder ticks by needed phase shift offsets (FOR PHASE C)
// shift to the left , positive shift
if(out>= (lookup_table_size-(offset_0+ phaseShift_2)) ){
   currentStepC = abs((lookup_table_size) - ((offset_0+ phaseShift_2) + out));
}
if(out>= 0 and out < (lookup_table_size-(offset_0+ phaseShift_2))){
 currentStepC = out + (offset_0+ phaseShift_2);
}

EncoderCount = BLDC_encoder.getEncoderCount();

A = map(pwmSin[abs(currentStepA)],0,over,0,max_);
B = map(pwmSin[abs(currentStepB)],0,over,0,max_);
C = map(pwmSin[abs(currentStepC)],0,over,0,max_);

PWM_ACB();
}

  
}
